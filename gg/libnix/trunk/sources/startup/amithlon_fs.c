
#include <exec/types.h>
#include <exec/memory.h>
#include <proto/exec.h>

// This whole thing might seem strange, but
// 1) Each new process needs its own baseptr
//    -> allocate memory.
// 2) No data relocs *at all* may be generated by the compiler until
//    %fs is set up
//    -> use weired initialization.
// 3) We need to save the pointer to the memory allocation somewhere
//    -> tc_MemEntry is a good place.

#pragma pack(1)

//	00000004 <switch>:
//	   4:   64 a1 08 00 00  movl   %fs:0x8,%eax
//	   9:   00 
//	   a:   a3 00 00 00 00  movl   %eax,0x0
//	   f:   c3              ret    
//	
//	00000010 <launch>:
//	  10:   a1 00 00 00 00  movl   0x0,%eax
//	  15:   64 a3 08 00 00  movl   %eax,%fs:0x8
//	  1a:   00 
//	  1b:   c3              ret    

struct SwitchLaunch {
    APTR	baseptr;
    struct Switch {
	UBYTE	mov_fs8_eax[6];
	UBYTE	mov_eax;
	APTR	baseptrptr;
	UBYTE	ret;
    } switch_func;
    struct Launch {
	UBYTE	mov_eax;
	APTR	baseptrptr;
	UBYTE	mov_eax_fs8[6];
	UBYTE	ret;
    } launch_func;
};

#pragma pack()


BOOL EnableSwitchLaunch(struct ExecBase* SysBase) {
  struct MemList       memlist;
  struct Task*         me = FindTask(NULL);
  struct MemList*      ml;
  struct SwitchLaunch* switchlaunch;

  memlist.ml_NumEntries      = 1;
  memlist.ml_ME[0].me_Reqs   = MEMF_PUBLIC | MEMF_REVERSE | MEMF_CLEAR;
  memlist.ml_ME[0].me_Length = sizeof (struct SwitchLaunch);

  ml = AllocEntry(&memlist);

  if (ml == NULL || (ULONG) ml->ml_ME[0].me_Addr & (1UL << 31)) {
    FreeEntry(ml);
    return FALSE;
  }
  else {
    // Free this memory allocation in RemTask() instead
    AddHead(&me->tc_MemEntry, &ml->ml_Node);
  }
    
  switchlaunch = (struct SwitchLaunch*) ml->ml_ME[0].me_Addr;

  switchlaunch->switch_func.mov_fs8_eax[0] = 0x64;
  switchlaunch->switch_func.mov_fs8_eax[1] = 0xa1;
  switchlaunch->switch_func.mov_fs8_eax[2] = 0x08;
  switchlaunch->switch_func.mov_eax = 0xa3;
  __asm__ volatile ("movl %1, (%0)"
		    :
		    : "q" (&switchlaunch->switch_func.baseptrptr),
		      "q" (&switchlaunch->baseptr));
  switchlaunch->switch_func.ret = 0xc3;
  switchlaunch->launch_func.mov_eax = 0xa1;
  __asm__ volatile ("movl %1, (%0)"
		    :
		    : "q" (&switchlaunch->launch_func.baseptrptr),
		      "q" (&switchlaunch->baseptr));
  switchlaunch->launch_func.mov_eax_fs8[0] = 0x64;
  switchlaunch->launch_func.mov_eax_fs8[1] = 0xa3;
  switchlaunch->launch_func.mov_eax_fs8[2] = 0x08;
  switchlaunch->launch_func.ret = 0xc3;

  // Fill in the "fastcalls"
  Forbid();
  me->tc_Switch = (void (*)()) ((UBYTE*) &switchlaunch->switch_func) + 3;
  me->tc_Launch = (void (*)()) ((UBYTE*) &switchlaunch->launch_func) + 3;
  me->tc_Flags |= (TF_SWITCH | TF_LAUNCH);
  Permit();
  
  return TRUE;
}

void DisableSwitchLaunch(struct ExecBase* SysBase) {
  struct Task* me = FindTask(NULL);

  Forbid();
  me->tc_Flags &= ~(TF_SWITCH | TF_LAUNCH);
  Permit();
}
