#!/usr/bin/perl -w                                      -- # -*- perl -*-
#
#     SFDCompile - Compile SFD files into someting useful
#     Copyright (C) 2003 Martin Blom <martin@blom.org>
#     
#     This program is free software; you can redistribute it and/or
#     modify it under the terms of the GNU General Public License
#     as published by the Free Software Foundation; either version 2
#     of the License, or (at your option) any later version.
#     
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#     
#     You should have received a copy of the GNU General Public License
#     along with this program; if not, write to the Free Software
#     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

use IO::Handle;
use Getopt::Long;
use Pod::Usage;

sub parse_sfd ( $ );
sub parse_proto ( $$ );
sub open_output ( $$ );
sub will_close_output ( $$ );
sub close_output ();


################################################################################
### Main program ###############################################################
################################################################################

Getopt::Long::Configure ("bundling");

my $help    = '0';
my $man     = '0';
my $mode    = 'dump';
my $output  = '-';
my $quiet   = '0';
my $target  = 'm68k-unknown-amigaos';
my $version = '0';

GetOptions ('help|h|?'   => \$help,
	    'man'        => \$man,
	    'mode=s'     => \$mode,
	    'output|o=s' => \$output,
	    'quiet|q'    => \$quiet,
	    'target=s'   => \$target,
	    'version|v'  => \$version) or exit 10;

if ($version) {
    print STDERR "SFDCompile 1.0 (16.07.2003)\n";
    print STDERR "Copyright (C) 2003 Martin Blom <martin\@blom.org>\n";
    print STDERR "This is free software; " .
	"see the source for copying conditions.\n";
    exit 0;
}

if ($help) {
    pod2usage(1);
    exit 0;
}

if ($man) {
    pod2usage(-exitstatus => 0, -verbose => 2);
    exit 0;
}

if ($#ARGV < 0) {
    pod2usage(1);
    exit 10;
}

$mode = lc $mode;

if (!($mode =~ /^(clib|dump|fd|macro|proto)$/)) {
    pod2usage(1);
    exit 10;
}

# Save old STDOUT

open( OLDOUT, ">&STDOUT" );

for my $i ( 0 .. $#ARGV ) {
    my $sfd = parse_sfd ($ARGV[$i]);
    my $num = $#{$$sfd{'prototypes'}};

    my $obj;

    for ($mode) {
	/^clib$/ && do {
	    $obj = CLib->new( sfd => $sfd );
	    last;
	};

	/^fd$/ && do {
	    $obj = FD->new( sfd => $sfd );
	    last;
	};
    
	/^dump$/ && do {
	    $obj = Dump->new( sfd => $sfd );
	    last;
	};
    
	/^macro$/ && do {
	    $obj = Macro->new( sfd => $sfd );
	    last;
	};

	/^proto$/ && do {
	    $obj = Proto->new( sfd => $sfd );
	    last;
	};

	die "Unknown mode specified: " . $mode;
    }


    for my $j ( 0 .. $num + 1) {
	my $prototype = $$sfd{'prototypes'}[$j];
	my $funcname  = $$prototype{'funcname'};
	
	if (!defined ($funcname) || will_close_output ($sfd, $funcname) != 0) {
	    $obj->footer ();
	}

	if ($j > $num) {
	    last;
	}
	
	if (open_output ($sfd, $funcname) != 0) {
	    $obj->header ();
	}

	$obj->function (prototype => $prototype);
    }

    close_output ();
}

if (!$quiet) {
    print STDERR "All done.\n";
}

open (STDOUT, ">&OLDOUT");
close (OLDOUT);

exit 0;






################################################################################
### Subroutines ################################################################
################################################################################


### parse_sfd: Parse a SFD file hand return a hash record ######################

sub parse_sfd ( $ ) {
    my $file = shift;
    local *SFD;

    my $type    = 'function';
    my $private = 0;
    my $bias    = 0;
    my $version = 1;
    my $comment = '';

    my $result = {
	copyright  => 'Copyright © 2001 Amiga, Inc.',
	id         => '',
	libname    => '',
	base       => '',
	basetype   => '',
	includes   => (),
	prototypes => (),
	basename   => '',
	BASENAME   => '',
	Basename   => ''
    };

    # Why do I need this????
    $$result{'includes'} = ();

    my $proto_line = '';
    my %proto;

    if (!$quiet) {
	( my $fn = $file ) =~ s,.*[/\\](.*),$1,;
	print STDERR "Processing SFD file '$fn'.\n";
	STDERR->flush();
    }
    
    unless (open (SFD, "<" . $file)) {
	print STDERR "Unable to open file '$file'.\n";
	die;
    };

    my $line_no = 0;

  LINE:
    while (my $line = <SFD>) {

	++$line_no;
	
	for ($line) {
	    /==copyright\s/ && do {
		( $$result{'copyright'} = $_ ) =~ s/==copyright\s+(.*)\s*/$1/;
		last;
	    };

	    /==id\s+/ && do {
		( $$result{'id'} = $_ ) =~ s/==id\s+(.*)\s*/$1/;
		last;
	    };

	    /==libname\s+/ && do {
		( $$result{'libname'} = $_ ) =~ s/==libname\s+(.*)\s*/$1/;
		last;
	    };

	    /==base\s+/ && do {
		( $$result{'base'} = $_ ) =~ s/==base\s+_?(.*)\s*/$1/;
		last;
	    };

	    /==basetype\s+/ && do {
		( $$result{'basetype'} = $_ ) =~ s/==basetype\s+(.*)\s*/$1/;
		last;
	    };

	    /==include\s+/ && do {
		( my $inc = $_ ) =~ s/==include\s+(.*)\s*/$1/;

		push @{$$result{'includes'}}, $inc;
		last;
	    };
	    
	    /==bias\s+/ && do {
		( $bias = $_ ) =~ s/==bias\s+(.*)\s*/$1/;
		last;
	    };

	    /==reserve\s+/ && do {
		( my $reserve = $_ ) =~ s/==reserve\s+(.*)\s*/$1/;

		$bias += 6 * $reserve;
		last;
	    };

	    /==alias\s*$/ && do {
		$type = 'alias';
		# Move back again
		$bias -= 6;
		last;
	    };

	    /==varargs\s*$/ && do {
		$type = 'varargs';
		# Move back again
		$bias -= 6;
		last;
	    };
	    
	    /==private\s*$/ && do {
		$private = 1;
		last;
	    };

	    /==public\s*$/ && do {
		$private = 0;
		last;
	    };

	    /==version\s+/ && do {
		( $version = $_ ) =~ s/==version\s+(.*)\s*/$1/;
		last;
	    };
	    
	    /==end\s*$/ && do {
		last LINE;
	    };
	    
	    /^\*/ && do {
		( my $cmt = $_ ) =~ s/^\*(.*)\s*/$1/;

		$comment .= ($comment eq '' ? "" : "\n" ) . $cmt;
		last;
	    };
	    
	    /^[^=*\n]/ && do {
		# Strip whitespaces and append
		$line =~ s/\s*(.*)\s*/$1/;
		$proto_line .= $line . " ";
		last;
	    };

	    /^\s*$/ && do {
		# Skip blank lines
		last;
	    };

	    # If we get here, we found a line we don't understand
	    print STDERR "Unable to parse line $line_no in SFD file" .
		" '$file'. The line looks like this:\n" . $line ;
	    die;
	};
	
	if ( $proto_line =~
	     /.*[A-Za-z0-9_]+\(.*\).*\(([\saAdD][0-7]-?,?)*\)\s*$/ ) {
	    push @{$$result{'prototypes'}}, {
		type    => $type,
		value   => $proto_line,
		line    => $line_no,
		private => $private,
		bias    => $bias,
		version => $version,
		comment => $comment
	    };

	    $type       = 'function';
	    $comment    = '';
	    $proto_line = '';
	    $bias += 6;
	}
    }

    if( $proto_line ne '' ) {
	# If $proto_line isn't empty, we couldn't parse it
	die "Unhanled proto '" . $proto_line . "'\n";
    }

    close (SFD);

    # Now parse the prototypes
    my $real_funcname = '';
    my $varargs_type   = '';

    for my $i ( 0 .. $#{$$result{'prototypes'}} ) {
	my $prototype = $$result{'prototypes'}[$i];

	if ($$prototype{'type'} ne 'function') {
	    $$prototype{'real_funcname'} = $real_funcname;
	}
	
	parse_proto ($prototype, $varargs_type);

	if ($$prototype{'type'} ne 'varargs' &&
	    $$prototype{'type'} ne 'stdarg') {
	    $varargs_type = $$prototype{'argtypes'}[$#{$$prototype{'argtypes'}}];
	}

	if ($$prototype{'type'} eq 'function') {
	    $real_funcname = $$prototype{'funcname'}
	}
    };

    # Create some other variables

    ( $$result{'basename'} = $$result{'libname'} ) =~ s/(.*)\.\w+/$1/;

    if ($$result{'basename'} eq '') {
	( $$result{'basename'} = $file ) =~ s:.*/(\w+?)_lib\.sfd:$1:;
    }

    if ($$result{'basename'} eq '') {
	print STDERR "Unable to find or guess base name.\n";
	die;
    }
    
    $$result{'basename'} = lc $$result{'basename'};
    $$result{'BASENAME'} = uc $$result{'basename'};
    $$result{'Basename'} = ucfirst $$result{'basename'};

    return $result;
}


### parse_proto: Parse a single function prototype  ############################

sub parse_proto ( $$ ) {
    my $prototype      = shift;
    my $varargs_type   = shift;
    
    my $return;
    my $struct;     # Just a dummy
    my $name;
    my $arguments;
    my $registers;

    if (!(($return,$struct,$name,$arguments,$registers) =
	  ( $$prototype{'value'} =~
	    /^((struct\s+)?\w+\s*?\**)\s*(\w+)\s*\((.*)\)\s*\((.*)\).*/ ))) {
	print STDERR "Unable to parse prototype on line $$prototype{'line'}.\n";
	die;
    }

    # Nuke whitespaces from the register specification
    $registers =~ s/\s//;

    $$prototype{'return'}     = $return;
    $$prototype{'funcname'}   = $name;
    @{$$prototype{'args'}}     = ();
    @{$$prototype{'regs'}} = split(/,/,lc $registers);  # Make regs lower case
    @{$$prototype{'argnames'}} = ();                    # Initialize array
    @{$$prototype{'argtypes'}} = ();                    # Initialize array

    my @args = split(/,/,$arguments);

    # Fix function pointer arguments and build $$prototype{'args'} 

    my $par_cnt = 0;
    foreach $arg (@args) {
	# Strip whitespaces
	$arg =~ s/\s*(.*?)\s*/$1/;

	if ($par_cnt != 0) {
	    my $old_arg = pop @{$$prototype{'args'}};
	    
	    push @{$$prototype{'args'}}, $old_arg . "," . $arg;
	}
	else {
	    push @{$$prototype{'args'}}, $arg;
	}

	# Count parentheses (a function pointer arguments is processed
	# when $par_cnt is 0).
	$par_cnt += ( $arg =~ tr/\(/\(/ );
	$par_cnt -= ( $arg =~ tr/\)/\)/ );
    }

    # varags -> stdarg (stdarg is a tag list) Example:
    # varargs: LONG Printf( STRPTR format, ... );
    # stdarg: BOOL AslRequestTags( APTR requester, Tag Tag1, ... );

    if ($$prototype{'type'} eq 'varargs' &&
	$varargs_type =~ /^\s*(const|CONST)?\s*struct\s+TagItem\s*\*\s*$/ ) {
	$$prototype{'type'} = 'stdarg';
    }
    
    # Make sure we have the same number of arguments as registers, or,
    # if this is a stdarg function, possible one extra, á la "Tag, ..."
    
    if ( !($#{$$prototype{'args'}} == $#{$$prototype{'regs'}} || 
	   (($$prototype{'type'} eq 'stdarg' ||
	     $$prototype{'type'} eq 'varargs') &&
	    $#{$$prototype{'args'}} == $#{$$prototype{'regs'}} + 1)) ) {

	print STDERR "Failed to parse arguments/registers on SFD " .
	    "line $$prototype{'line'}:\n$$prototype{'value'}\n";
	die;
    }

    my $type = '';
    
    foreach $arg (@{$$prototype{'args'}}) {
	my $name  = '';

	if ($arg =~ /.*\(.*?\)\s*\(.*\)/) {
	    my $type1;
	    my $type2;
	    
	    ($type1, $name, $type2) =
		( $arg =~ /^\s*(.*)\(\s*\*\s*(\w+)\s*\)\s*(\(.*\))\s*/ );
	    $type = $type1 . "(*)" . $type2;
	}
	elsif ($arg !~ /^\.\.\.$/) {
	    ($type, $name) = ( $arg =~ /^\s*(.*?)\s+(\w+)\s*$/ );
	}
	else {
	    $type = $varargs_type;
	    $name = '...';
	}

	if ($type eq '' || $name eq '' ) {
	    print STDERR "Type or name missing from '$arg'.\n";
	    die;
	}
	
	push @{$$prototype{'argnames'}}, $name;
	push @{$$prototype{'argtypes'}}, $type;
    }
}



sub BEGIN {
    my $old_output = '';


### close_output: Close the output file if necessary  ##########################

    sub close_output () {
	close (STDOUT);
	$old_output = '';
    }
    

### check_output: Check if the file will be reopended by open_output ###########

    sub will_close_output ( $$ ) {
	my $sfd      = shift;
	my $function = shift;

	my $new_output = $output;

	$new_output =~ s/%f/$function/;
	$new_output =~ s/%b/$$sfd{'base'}/;
	$new_output =~ s/%l/$$sfd{'libname'}/;
	$new_output =~ s/%n/$$sfd{'basename'}/;

	if( $old_output ne '' &&
	    $new_output ne $old_output ) {
	    return 1;
	}
	else {
	    return 0;
	}
    }
    
### open_output: (Re)open the output file if necessary  ########################

    sub open_output ( $$ ) {
	my $sfd      = shift;
	my $function = shift;

	my $new_output = $output;

	$new_output =~ s/%f/$function/;
	$new_output =~ s/%b/$$sfd{'base'}/;
	$new_output =~ s/%l/$$sfd{'libname'}/;
	$new_output =~ s/%n/$$sfd{'basename'}/;

	if( $new_output ne $old_output ) {

	    close_output ();

	    if ($new_output eq '-') {
		open (STDOUT, ">&OLDOUT") or die;
	    }
	    else {
		open (STDOUT, ">" . $new_output) or die;

		if (!$quiet) {
		    print STDERR "Writing to '$new_output'\n";
		}
	    }
	    
	    $old_output = $new_output;

	    return 1;
	}
	else {
	    return 0;
	}
    }
}


### Class CLib: Create a clib file #############################################

{
    package CLib;
    use strict;

    sub new {
	my $proto  = shift;
	my %params = @_;
	my $class  = ref($proto) || $proto;
	my $self   = {};
	$self->{SFD}     = $params{'sfd'};
	$self->{VERSION} = 1;
	bless ($self, $class);
	return $self;
    }

    sub header {
	my $self = shift;
	my $sfd  = $self->{SFD};

	my $id = $$sfd{'id'};
	my $v  = $id;
	my $d  = $id;

	$v =~ s/^\$[I]d: .*? ([0-9.]+).*/$1/;
	$d =~ s,^\$[I]d: .*? [0-9.]+ (\d{4})/(\d{2})/(\d{2}).*,($3.$2.$1),;
		
	print "/* Automatically generated header! Do not edit! */\n";
	print "\n";
	print "#ifndef CLIB_$$sfd{'BASENAME'}_PROTOS_H\n";
	print "#define CLIB_$$sfd{'BASENAME'}_PROTOS_H\n";
	print "\n";
	print "/*\n";
	print "**	\$VER: $$sfd{'basename'}_protos.h $v $d\n";
	print "**\n";
	print "**	C prototypes. For use with 32 bit integers only.\n";
	print "**\n";
	print "**	$$sfd{'copyright'}\n";
	print "**	    All Rights Reserved\n";
	print "*/\n";
	print "\n";

	foreach my $inc (@{$$sfd{'includes'}}) {
	    print "#include $inc\n";
	}

	print "\n";
	print "#ifdef __cplusplus\n";
	print "extern \"C\" {\n";
	print "#endif /* __cplusplus */\n";
	print "\n";

	$self->{VERSION} = 1;
    }

    sub function {
	my $self     = shift;
	my %params    = @_;
	my $prototype = $params{'prototype'};
	my $sfd       = $self->{SFD};
	
	if ($self->{VERSION} != $$prototype{'version'}) {
	    $self->{VERSION} = $$prototype{'version'};

	    print "\n";
	    print "/*--- functions in V$self->{VERSION} or higher ---*/\n";
	}
	
	if ($$prototype{'comment'} ne '') {
	    my $comment = $$prototype{'comment'};

	    $comment =~ s,^(\s?)(.*),/*$1$2$1*/,m;
		
	    print "\n";
	    print "$comment\n";
	}
	
	my $args = join (', ',@{$$prototype{'args'}});

	if ($args eq '') {
	    $args = "void";
	}
	
	print "$$prototype{'return'} $$prototype{'funcname'}($args);\n";
    }

    sub footer {
	my $self = shift;
	my $sfd  = $self->{SFD};

	print "\n";
	print "#ifdef __cplusplus\n";
	print "}\n";
	print "#endif /* __cplusplus */\n";
	print "\n";
	print "#endif /* CLIB_$$sfd{'BASENAME'}_PROTOS_H */\n";
    }
}


### Class Dump: Dump SFD info ##################################################

{
    package Dump;
    use strict;

    sub new {
	my $proto    = shift;
	my %params   = @_;
	my $class    = ref($proto) || $proto;
	my $self     = {};
	$self->{SFD} = $params{'sfd'};
	bless ($self, $class);
	return $self;
    }

    sub header {
	my $self = shift;
	my $sfd  = $self->{SFD};

	print "SFD information\n";
	print "¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\n";
	print "Copyright:		$$sfd{'copyright'}\n";
	print "RCS ID:			$$sfd{'id'}\n";
	print "Module name:		$$sfd{'libname'}\n";
	print "Module base:		$$sfd{'base'}\n";
	print "Module base type:	$$sfd{'basetype'}\n";
	print "Module base names:	$$sfd{'basename'}, $$sfd{'BASENAME'}, ";
	print "$$sfd{'Basename'}\n";
	print "\n";
	print "Include files:		";
	print join ("\n			", @{$$sfd{'includes'}});
	print "\n";
	print "\n";
    }

    sub function {
	my $self      = shift;
	my %params    = @_;
	my $prototype = $params{'prototype'};
	my $sfd       = $self->{SFD};

	print "* Line $$prototype{'line'}: $$prototype{'funcname'}()\n";
	print "	Type:			" . ucfirst $$prototype{'type'} . "\n";
	if ($$prototype{'type'} ne 'function') {
	    print "	Real function name:\t$$prototype{'real_funcname'}\n";
	}
	print "	Visibility:		";
	print $$prototype{'private'} == 0 ? "Public\n" : "Private\n";
	print "	Library offset/bias:	-$$prototype{'bias'}\n";
	print "	Available since:	V$$prototype{'version'}\n";
	print "	Comment:		$$prototype{'comment'}\n";
	print "\n";
	print "	Return value:		$$prototype{'return'}\n";
	print "	Argument names:		";
	print join (", ", @{$$prototype{'argnames'}});
	print "\n";
	print "	Argument types:		";
	print join (",\n\t\t\t\t", @{$$prototype{'argtypes'}});
	print "\n";

	print "\n";

#		value   => $proto_line,

#    $$prototype{'return'}     = $return;
#    $$prototype{'funcname'}   = $name;
#    @{$$prototype{'args'}}     = ();
#    @{$$prototype{'regs'}} = split(/,/,lc $registers);  # Make regs lower case
#    @{$$prototype{'argnames'}} = ();                    # Initialize array
#    @{$$prototype{'argtypes'}} = ();                    # Initialize array
    }

    sub footer {
	print "\n";
    }
}


### Class FD: Create an old-style FD file ######################################

{
    package FD;
    use strict;

    sub new {
	my $proto  = shift;
	my %params = @_;
	my $class  = ref($proto) || $proto;
	my $self   = {};
	$self->{SFD}     = $params{'sfd'};
	$self->{BIAS}    = -1;
	$self->{PRIVATE} = -1;
	$self->{VERSION} = 1;
	bless ($self, $class);
	return $self;
    }

    sub header {
	my $self = shift;
	my $sfd  = $self->{SFD};

	print "* \"$$sfd{'libname'}\"\n";
	print "* Automatically generated FD! Do not edit!\n";
	print "##base _$$sfd{'base'}\n";
	$self->{BIAS}    = -1;
	$self->{PRIVATE} = -1;
	$self->{VERSION} = 1;
    }

    sub function {
	my $self      = shift;
	my %params    = @_;
	my $prototype = $params{'prototype'};
	my $sfd       = $self->{SFD};

	if ($$prototype{'type'} eq 'function') {
	    if ($self->{BIAS} != $$prototype{'bias'}) {
		$self->{BIAS} = $$prototype{'bias'};
		print "##bias $self->{BIAS}\n";
	    }

	    if ($self->{PRIVATE} != $$prototype{'private'}) {
		$self->{PRIVATE} = $$prototype{'private'};
		print $self->{PRIVATE} == 1 ? "##private\n" : "##public\n";
	    }

	    if ($self->{VERSION} != $$prototype{'version'}) {
		$self->{VERSION} = $$prototype{'version'};

		print "*--- functions in V$self->{VERSION} or higher ---\n";
	    }

	    if ($$prototype{'comment'} ne '') {
		my $comment = $$prototype{'comment'};

		$comment =~ s/^/\*/m;
		
		print "$comment\n";
	    }
	    
	    print "$$prototype{'funcname'}(";
	    print join (',', @{$$prototype{'argnames'}});
	    print ")(";
	    print join (',', @{$$prototype{'regs'}});
	    print ")\n";
	
	    $self->{BIAS} += 6;
	}
    }
    
    sub footer {
	my $self = shift;

	print "##end\n";
    }
}


### Class Macro: Create a macro file ###########################################

{
    package Macro;
    use strict;

    sub new {
	my $proto  = shift;
	my %params = @_;
	my $class  = ref($proto) || $proto;
	my $self   = {};
	$self->{SFD}  = $params{'sfd'};
	$self->{BASE} = "${$self->{SFD}}{'BASENAME'}_BASE_NAME";
	$self->{BASE} =~ s/^([0-9])/_$1/;
	bless ($self, $class);
	return $self;
    }

    sub header {
	my $self = shift;
	my $sfd  = $self->{SFD};

	print "/* Automatically generated header! Do not edit! */\n";
	print "\n";
	print "#ifndef INLINE_$$sfd{'BASENAME'}_H\n";
	print "#define INLINE_$$sfd{'BASENAME'}_H\n";
	print "\n";
	print "#ifndef __INLINE_MACROS_H\n";
	print "#include <inline/macros.h>\n";
	print "#endif /* !__INLINE_MACROS_H */\n";
	print "\n";

	if ($$sfd{'base'} ne '') {
	    print "#ifndef $self->{BASE}\n";
	    print "#define $self->{BASE} $$sfd{'base'}\n";
	    print "#endif /* !$self->{BASE} */\n";
	    print "\n";
	}
    }

    sub function {
	my $self      = shift;
	my %params    = @_;
	my $prototype = $params{'prototype'};
	my $sfd       = $self->{SFD};

	if ($$prototype{'type'} eq 'stdarg') {
	    print "#ifndef NO_INLINE_STDARG\n";
	}
	elsif ($$prototype{'type'} eq 'varargs') {
	    print "##ifndef NO_INLINE_VARARGS\n";
	}
	
	$self->function_define (prototype => $prototype);
	$self->function_start (prototype => $prototype);
	$self->function_end (prototype => $prototype);

	if ($$prototype{'type'} eq 'stdarg') {
	    print "#endif /* !NO_INLINE_STDARG */\n";
	}
	elsif ($$prototype{'type'} eq 'varargs') {
	    print "##endif /* !NO_INLINE_VARARGS */\n";
	}

	print "\n";
    }

    sub footer {
	my $self = shift;
	my $sfd  = $self->{SFD};

	print "\n";
	print "#endif /* INLINE_$$sfd{'BASENAME'}_H */\n";
    }


    # Helper functions
    
    sub function_define {
	my $self     = shift;
	my %params   = @_;
	my $prototype = $params{'prototype'};
	my $sfd      = $self->{SFD};

	my @argnames ;

	foreach my $arg (@{$$prototype{'argnames'}}) {
	    $arg =~ s/^(\w)/___$1/;
	    push @argnames, $arg;
	}

	print "#define $$prototype{'funcname'}(";
	print join (',', @argnames);
	print ") \\\n";
    }

    sub function_start {
	my $self      = shift;
	my %params    = @_;
	my $prototype = $params{'prototype'};
	my $sfd       = $self->{SFD};
    }

    sub function_end {
	my $self      = shift;
	my %params    = @_;
	my $prototype = $params{'prototype'};
	my $sfd       = $self->{SFD};

	if ($$prototype{'type'} !~ /^(varargs|stdarg)$/ &&
	    $$sfd{'base'} ne '') {
	    print "	, $self->{BASE})\n";
	}
	else {
	    print "	)\n";
	}
    }
}


### Class Proto: Create a proto file ###########################################

{
    package Proto;
    use strict;

    sub new {
	my $proto    = shift;
	my %params   = @_;
	my $class    = ref($proto) || $proto;
	my $self     = {};
	$self->{SFD} = $params{'sfd'};
	bless ($self, $class);
	return $self;
    }

    sub header {
	my $self = shift;
	my $sfd  = $self->{SFD};

	my $base     = $$sfd{'base'};
	my $basename = $$sfd{'basename'};
	my $BASENAME = $$sfd{'BASENAME'};
	my $basetype = $$sfd{'basetype'};

	print "/* Automatically generated header! Do not edit! */\n";
	print "\n";
	print "#ifndef PROTO_${BASENAME}_H\n";
	print "#define PROTO_${BASENAME}_H\n";
	print "\n";
	print "#include <clib/${basename}_protos.h>\n";
	print "\n";
	print "#ifndef _NO_INLINE\n";
	print "# ifdef __GNUC__\n";
	print "#  ifdef __amigaos4__\n";
	print "#   ifdef __USE_INLINE__\n";
	print "#    include <inline4/${basename}.h>\n";
	print "#   endif /* __USE_INLINE__ */\n";
	print "#  else /* !__amigaos4__ */\n";
	print "#   include <inline/${basename}.h>\n";
	print "#  endif /* __amigaos4__ */\n";
	print "# endif /* __GNUC__ */\n";
	print "#endif /* _NO_INLINE */\n";
	print "\n";

	if ($base ne '') {
	    print "#ifdef __amigaos4__\n";
	    print "# include <interfaces/${basename}.h>\n";
	    print "# ifndef __NOGLOBALIFACE__\n";
	    print "   extern struct ${base}IFace *I${base};\n";
	    print "# endif /* __NOGLOBALIFACE__*/\n";  
	    print "#else /* !__amigaos4__ */\n";
	    print "# ifndef __NOLIBBASE__\n";
	    print "   extern ${basetype}\n";
	    print "#  ifdef __CONSTLIBBASEDECL__\n";
	    print "    __CONSTLIBBASEDECL__\n";
	    print "#  endif /* __CONSTLIBBASEDECL__ */\n";
	    print "   ${base};\n";
	    print "# endif /* !__NOLIBBASE__ */\n";
	    print "\n";
	}
    }

    sub function {
	# Nothing to do here ...
    }

    sub footer {
	my $self = shift;
	my $sfd  = $self->{SFD};

	print "#endif /* !PROTO_$$sfd{'BASENAME'}_H */\n";
    }
}


### Help message and manual page ###############################################

__END__

=head1 NAME

SFDCompile - Compile SFD files into someting useful

=head1 SYNOPSIS

SFDCompile [options] file.sfd

  Options:
    --help -h -?            Show brief help message and exit
    --man                   Show a manual page.
    --mode=MODE             What to do
    --output=FILE -o FILE   Where to store the output
    --quiet -q              Be quiet
    --target=TARGET         Specifies the machine target
    --version -v            Show version and exit

=head1 OPTIONS

=over 8


=item B<--help>

Show a brief help message and then exit.

    
=item B<--man>

Show the complete manual page.


=item B<--mode>

Instructs F<SFDCompile> what to do. F<SFDCompile> can handle B<clib>,
B<dump>, B<fd>, B<macro> and B<proto> arguments.

=over 8

=item B<clib>

Generate C prototypes to be placed in F<Include/clib>.


=item B<dump>

Dumps all information gathered from a SFD file. This is the default.


=item B<fd>

Generate an old-style FD file.

    
=item B<macro>

Generate a headerfile containing F<gcc> specific preprocessor macros,
similar to F<fd2inline>'s B<--new> switch. For targets, it generates a
file suitable to be placed in the F<Include/defines> directory.

    
=item B<proto>

Generate header file to be placed in F<Include/proto> that includes
the C prototypes as well as compiler-specific inlines or pragma files.

=back


=item B<--output> 

Specifies where the result will be stored. The followign escape
sequencies are allowed in the file name. If the sequence B<%f> is
present in the name, a new file will be created for each function
processed.

=over 8

=item B<%b>

The library base variable name (C<_DOSBase>, for example).

=item B<%f>

The current funcion name (C<Open>, for example).

=item B<%l>

The name of the library or device (F<dos.library>, for example).

=item B<%n>

The base name of the library or device (C<dos>, for example).

=back

If omitted, the result will be sent to the standard output instead of
a file.

=item B<--quiet>

Be quiet.


=item B<--target>

Specifies the target when generating macros etc. The default is
B<m68k-unknown-amigaos>.

=item B<--version>

Prints the version and exits.


=back

=head1 DESCRIPTION

F<SFDCompile> is an open source replacement for Amiga, Inc.'s F<sfd>
tool, distributed with B<NDK 3.9>. It is also an replacement for
F<fd2inline> from GeekGadgets and the MorphOS team, later improved to
death by Martin Blom. It's now a complete mess and needs a
replacement. SFD files and F<SFDCompile> might to be a good start.


=head1 RETURN VALUE

Returns 0 on success and 10 on errors.


=head1 AUTHOR

Martin Blom <martin@blom.org>

=head1 HISTORY

=item B<1.0 (2003-07-16)>

Initial release.


=out
